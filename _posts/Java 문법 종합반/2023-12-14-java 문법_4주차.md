---
title: java 문법 종합반_4주차
author: eunchaelyu
date: 2023-12-14 12:30:00 +0900
categories: [항해99, java 문법]
tags: [항해99]
pin: true
img_path: '/posts/20231214'
---

# java 문법 종합반_4주차        
  [목표]    
> 1. 오류 및 예외에 대해 예외처리    
> 2. Generic 제네릭
> 3. Collection 컬랙션  

## 오류 및 예외에 대해 예외처리     
> - 오류: 일반적으로 회복이 불가능한 (시스템 레벨)    
> - 예외: 일반적으로 회복이 **가능한** (코드 레벨)    

### 예외 종류        
1. 코드 실행 관점    
- 컴파일 에러: 있지 않은 클래스를 호출한다거나 접근이 불가능한 프로퍼티나 메소드에 접근할 때 발생
  문법에 맞게 다시 작성 필요!    
- 런타임 에러: 프로그램 실행도중 발생하는 예외    

2. 예외처리 관점    
- 확인된 예외: 컴파일 시점(이미 특정한 문제를 인지 하고 있어서 컴파일 하는 동안 확인 가능)     
- 미확인된 예외: run 타임 시점 확인되는 예외    

### 예외 처리 흐름    
- [x] 우리가 예외를 어떻게 정의할 것인가 (예외 클래스를 만들어서 예외를 정의)    
- [x] 예외가 발생 할 수 있음을 알림 
- [x] 사용자는 예외가 발생 할 수 있음을 알고 예외를 핸들링 하는가

### throw, throws 메서드    

|throws                                                                        |throw                                                |             
|:----------------------------------------------------------------------------:|:----------------------------------------------------:|      
|메서드 이름 뒤에 붙어 이 메서드가 어떠한 예외사항을 던질 수 있는지 알려주는 예약어|메서드 안에서 실제로 예외 객체를 던질 때 사용하는 예약어 |          
|여러 종류의 예외사항 적을 수 있다                                              |실제로 던지는 예외 객체 하나와 같이 써야 함               |          
|                                                                             |throw 아래의 구문들은 실행되지 않고 종료됨              |      


```java
public class StudyException {
    public static void main(String[] args) {
        OurClass ourClass = new OurClass(); //인스턴스화

        try {
            ourClass.thisMethodIsDangerous();
        } catch (OurBadException e) {
            System.out.println(e.getMessage());
        } finally {
            System.out.println("우리는 방금 예외를 handling 했습니다!");
        }

    }
}
```

### try-catch문     
> 로직
![image](https://github.com/eunchaelyu/eunchaelyu.github.io/assets/119996957/4ddd8349-d6fc-41e4-a749-8a4f835b8948)      

> 일단 ``try{}``하고 예외가 발생하면 ``OurBadException e``를 ``catch(){}``한다        
> ``e.getMessage()`` 메서드를 통해 예외 내용을 출력할 수 있다        
> ``finally{}``마침내 수행돼야 하는 로직을 수행한다        

### Throwable Class    
>  “문제 상황”을 뜻하는 Throwable 클래스가 Object 클래스를 상속    

![image](https://github.com/eunchaelyu/eunchaelyu.github.io/assets/119996957/711e0ad5-70c7-4d96-b55a-4e9f5af47157)        

- RuntimeException을 상속한 예외들은 UncheckedException    
  반대로 상속하지 않은 예외들은 CheckedException으로 구현    

### Chained Exception (연결된 예외)    
   인과관계를 설명할 수 있는 예외    

- initCause() 메서드: 지정한 예외를 원인 예외로 등록
- getCause() 메서드: 원인 예외를 반환

### 예외 처리하기
  1. 예외 복구하기 (자주 사용 X)
   
```java
   public String getDataFromAnotherServer(String dataPath) {
		try {
				return anotherServerClient.getData(dataPath).toString();
		} catch (GetDataException e) {
				return defaultData; // 종료하고 정상적인 데이터를 반환 
		}
}
```

  2. 예외 처리 회피하기 (흘려보낸다)      
       
```java
public void someMethod() throws Exception { ... }

public void someIrresponsibleMethod() throws Exception {
		this.someMethod();
}
```

  3. 예외 전환하기(예외처리에 더 신경쓰고싶은 경우)    
       
```java
public void someMethod() throws IOException { ... }

public void someResponsibleMethod() throws MoreSpecificException {
		try {
			this.someMethod();
		} catch (IOException e) {
			throw new MoreSpecificException(e.getMessage());
		}
}
```



## Generic 제네릭   

### 제네릭의 효용      
- 중복되거나 필요없는 코드를 줄여주는 것      
- 타입 안정성 유지

### 제네릭 문법    

```java
// (1)
public class Generic<T> {
		// (2)
    private T t;
    // (3)
    public T get() {
        return this.t;
    }

    public void set(T t) {
        this.t = t;
    }

    public static void main(String[] args) {
				// (4)
        Generic<String> stringGeneric = new Generic<>();
        stringGeneric.set("Hello World");
				
        String tValueTurnOutWithString = stringGeneric.get();

        System.out.println(tValueTurnOutWithString);
    }
}
```

  1. 제네릭은 클래스 또는 메서드에 사용,
     클래스 이름 뒤에 <> 문법 안에 들어가야 할 타입 변수(= T) 지정
     static은 사용 못한다
     
  2. private 프로퍼티인 t의 타입
     
  3. 메서드의 리턴타입에 들어감    

  4. 제네릭을 통해 구현한 클래스를 사용(실제 변수의 값을 넣어줘야 함)



## Collection 컬랙션
 - 자료구조를 구체화해서 java에 놓여놓은 것

### List 배열
> 추상적 자료구조, 순서가 있고 중복을 허용함 (Set 과 구별됨)    

![image](https://github.com/eunchaelyu/eunchaelyu.github.io/assets/119996957/416787dc-3d99-4d6f-9ed6-747bc445964a)

### List<E> 코드        

```java
// 실제 java.util의 List 코드
public interface List<E> extends Collection<E> { // 제네릭 인터페이스 
		int size();
    boolean isEmpty();
		...
		boolean addAll(Collection<? extends E> c);
		boolean add(E e);
		...
}      
```
- 타입변수 E    
- addAll()메서드의 인자에 조건이 두개 들어있다.    
    1. Collection 타입에 속하는 것    
    2. List의 타입변수 E의 자손 클래스를 원소로 가지고 있을 것    


